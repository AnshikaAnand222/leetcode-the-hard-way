"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[2049],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return d}});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function m(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var u=r.createContext({}),s=function(e){var n=r.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=s(e.components);return r.createElement(u.Provider,{value:n},e.children)},l={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},c=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,u=e.parentName,p=m(e,["components","mdxType","originalType","parentName"]),c=s(t),d=a,f=c["".concat(u,".").concat(d)]||c[d]||l[d]||i;return t?r.createElement(f,o(o({ref:n},p),{},{components:t})):r.createElement(f,o({ref:n},p))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=c;var m={};for(var u in n)hasOwnProperty.call(n,u)&&(m[u]=n[u]);m.originalType=e,m.mdxType="string"==typeof e?e:a,o[1]=m;for(var s=2;s<i;s++)o[s]=t[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}c.displayName="MDXCreateElement"},3154:function(e,n,t){t.r(n),t.d(n,{assets:function(){return p},contentTitle:function(){return u},default:function(){return d},frontMatter:function(){return m},metadata:function(){return s},toc:function(){return l}});var r=t(7462),a=t(3366),i=(t(7294),t(3905)),o=["components"],m={description:"Author: @wingkwong | https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/"},u="0421 - Maximum XOR of Two Numbers in an Array",s={unversionedId:"0400-0499/maximum-xor-of-two-numbers-in-an-array",id:"0400-0499/maximum-xor-of-two-numbers-in-an-array",title:"0421 - Maximum XOR of Two Numbers in an Array",description:"Author: @wingkwong | https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/",source:"@site/solutions/0400-0499/0421-maximum-xor-of-two-numbers-in-an-array.md",sourceDirName:"0400-0499",slug:"/0400-0499/maximum-xor-of-two-numbers-in-an-array",permalink:"/solutions/0400-0499/maximum-xor-of-two-numbers-in-an-array",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/solutions/0400-0499/0421-maximum-xor-of-two-numbers-in-an-array.md",tags:[],version:"current",lastUpdatedBy:"Wing-Kam Wong",lastUpdatedAt:1652366253,formattedLastUpdatedAt:"5/12/2022",sidebarPosition:421,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/"},sidebar:"tutorialSidebar",previous:{title:"0413 - Arithmetic Slices (Medium)",permalink:"/solutions/0400-0499/arithmetic-slices-medium"},next:{title:"0435 - Non-overlapping Intervals (Medium)",permalink:"/solutions/0400-0499/non-overlapping-intervals-medium"}},p={},l=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Bit Masking + Set + Two Sum Idea",id:"approach-1-bit-masking--set--two-sum-idea",level:2}],c={toc:l};function d(e){var n=e.components,t=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"0421---maximum-xor-of-two-numbers-in-an-array"},"0421 - Maximum XOR of Two Numbers in an Array"),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"Given an integer array ",(0,i.kt)("inlineCode",{parentName:"p"},"nums"),", return ",(0,i.kt)("em",{parentName:"p"},"the maximum result of")," ",(0,i.kt)("inlineCode",{parentName:"p"},"nums[i] XOR nums[j]"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"0 <= i <= j < n"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: nums = [3,10,5,25,2,8]\nOutput: 28\nExplanation: The maximum result is 5 XOR 25 = 28.\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 2:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: nums = [14,70,53,83,49,91,36,80,92,51,66,70]\nOutput: 127 \n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= nums.length <= 2 * 10^5")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0 <= nums[i] <= 2^31 - 1"))),(0,i.kt)("h2",{id:"approach-1-bit-masking--set--two-sum-idea"},"Approach 1: Bit Masking + Set + Two Sum Idea"),(0,i.kt)("p",null,"In order to maximise the answer, we can construct the max XOR from the leftmost bit. The best answer is always all bits set. Hence, we can check bit by bit. We need to find two numbers such that its XOR starts with ",(0,i.kt)("inlineCode",{parentName:"p"},"1000...000"),", then find ",(0,i.kt)("inlineCode",{parentName:"p"},"1100..000,")," then ",(0,i.kt)("inlineCode",{parentName:"p"},"1110...000"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"1111...000")," and till ",(0,i.kt)("inlineCode",{parentName:"p"},"1111...111"),". We build each mask to extract the prefix of length ",(0,i.kt)("inlineCode",{parentName:"p"},"(L - i)")," in binary representation of each number by using ",(0,i.kt)("inlineCode",{parentName:"p"},"num & mask"),". Then apply Two Sum idea, if the complement exists in the set, then we can update answer."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int findMaximumXOR(vector<int>& nums) {\n        int ans = 0, mask = 0;\n        for(int i = 31; i >= 0; i--){\n           unordered_set<int> s;\n            mask |= (1 << i);\n            for (auto x : nums) s.insert(mask & x);\n            int best = ans | (1 << i);\n            for(auto pref : s){\n                if(s.find(pref ^ best) != s.end()){\n                    ans = best;\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n};\n")))}d.isMDXComponent=!0}}]);